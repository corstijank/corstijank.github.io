<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing on Statics Must Die!</title>
    <link>http://staticsmustdie.net/tags/testing/index.xml</link>
    <description>Recent content in Testing on Statics Must Die!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</copyright>
    <atom:link href="http://staticsmustdie.net/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Crossing Styx - My journey into the (under)world of .NET - Part II</title>
      <link>http://staticsmustdie.net/post/dotnetcore-adventures-ii/</link>
      <pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://staticsmustdie.net/post/dotnetcore-adventures-ii/</guid>
      <description>

&lt;p&gt;In my previous &lt;a href=&#34;http://staticsmustdie.net/post/dotnetcore-adventures-i/&#34;&gt;post on this topic&lt;/a&gt;, I somehow got the jitters to get started with .NET. Or more specifically, .NET core. Being stubborn as I am, I have created a simple delivery pipeline in Jenkins, for building and deploying a .NET core docker container.&lt;/p&gt;

&lt;p&gt;Now, this might sound like hell freezing over. Me, programming .NET? Blasphemy! Except one little thing. For my previous post, I didn&amp;rsquo;t actually write one line of C# code. Now, I don&amp;rsquo;t want to give off the impression Im uncomfortable in &lt;strong&gt;any&lt;/strong&gt; programming language, and so  I made sure to end the last blog post with some unfulfilled promises of creating a more serious project from this &amp;lsquo;Hello world&amp;rsquo; example.&lt;/p&gt;

&lt;p&gt;Time to pay up.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://staticsmustdie.net/img/dotnet-jenkins-simple-pipeline.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Previously..... on StaticsMustDie&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;the-freedom-of-choice&#34;&gt;The freedom of choice&lt;/h2&gt;

&lt;p&gt;So, I spent some time fiddling around, on how C# services work. To create any kind of web service, there is the ASP.NET core framework. ASP.NET core and the base .NET core runtime seem kind of coupled in a non-technical way. Of course, nowadays, you&amp;rsquo;d be hard pressed &lt;strong&gt;not&lt;/strong&gt; to write some sort of web application. And so far, to my knowledge, ASP.NET is the way to go for all the .NET folks.&lt;/p&gt;

&lt;p&gt;Still, the distinction between .NET core and ASP.NET core might allow for some possible alternatives in the future? Or, maybe not. It&amp;rsquo;s kind of like how, back in the day Java EE (back then still J2EE 1.2, 1.3) had the same kind of monopoly on the JVM when it came to developing back-end software (we didn&amp;rsquo;t do any of your fancy &amp;lsquo;web services&amp;rsquo; back then). At one point, Spring came along and provided a (more pragmatic, in this case) alternative. Competition grew, and now, Java developers have a bunch of choices to make on what they use. But, ultimately, the choice kind of boils down to some stylistic differences, about which people love to get all religious. Yay for choice, right?&lt;/p&gt;

&lt;p&gt;Anyway, I digress. Back to the matter at hand.&lt;/p&gt;

&lt;h2 id=&#34;to-code-or-not-to-code&#34;&gt;To Code, or not to Code&lt;/h2&gt;

&lt;p&gt;So, the choice for ASP.NET core was simple. Now, was I going to write a small service myself? I had originally planned too, but then, life got in the way. The whole household came down with the flu, and suddenly I was feeling kind of pressed for time. If I&amp;rsquo;m going to do this blog thing, I want to have at least some regularity to it, you know?&lt;/p&gt;

&lt;p&gt;The thing is, writing my own service&amp;hellip;was it really that important? I could follow a tutorial like anybody else. If I were to blog on that, I would just reproduce the tutorial, and that would not be up to the standards I want to hold myself to. I want to focus on the interesting points, Docker, Jenkins, unit testing, acceptance testing.&lt;/p&gt;

&lt;p&gt;So, instead of writing about how to implement REST on C#/.NET core, I&amp;rsquo;ll be starting with some simple tutorial code here. The ASP.NET core documentation site has some excellent &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/tutorials/&#34; title=&#34;Awesome tutorials for learning ASP.NET core&#34;&gt;tutorials&lt;/a&gt;, and I really recommend you check them out. The code I&amp;rsquo;m starting with is the code explained the &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/tutorials/&#34; title=&#34;Awesome tutorials for learning ASP.NET core&#34;&gt;ASP.NET core tutorial&lt;/a&gt; on creating a simple rest service.&lt;/p&gt;

&lt;h2 id=&#34;lessons-learned&#34;&gt;Lessons learned&lt;/h2&gt;

&lt;p&gt;So, I had refactor some stuff, &amp;lsquo;git mv&amp;rsquo; some directory around, and basically wound up with something which was starting to look like a real project folder;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/global.json
/TodoApi/Jenkinsfile
/TodoApi/Dockerfile
/TodoApi/project.json
/TodoApi/**Code**
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our Dockerfile is clean and simple; and I&amp;rsquo;m not going to bother going into detail on it here. All I had to do was edit the Jenkinsfile (read the previous post to get up to speed on that) to make sure any running version of the container would be stopped before the deploy. This was not necesary before as the previous iteration of our container was, well..just printing &lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So, all should be well. Fire up the docker container. Query the service. Bask in .NET glory.&lt;/p&gt;

&lt;p&gt;Nope; ran into a few things that are well worth noting on here.&lt;/p&gt;

&lt;h3 id=&#34;inversion-of-control-just-on-a-different-level&#34;&gt;Inversion of Control. Just on a different level.&lt;/h3&gt;

&lt;p&gt;As I said, it was all relatively simple to start.  The container ran, but, when I tried to do a simple GET. It failed. Why? I got a simple &lt;code&gt;Empty Response&lt;/code&gt; as body text on my response. Why? Well there we have to look a bit deeper into the C# code, what it does, and how that holds up in our delivery choices.&lt;/p&gt;

&lt;p&gt;So, what does the code that start an http service look like?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var host = new WebHostBuilder()
                .UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseIISIntegration()
                .UseStartup&amp;lt;Startup&amp;gt;()
                .Build();
                
host.run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My first thought seeing this was &amp;lsquo;Oh look, a simple builder that starts some kind of service. Nice. Just like we do it in Java in every (micro) service framework that is not JEE. They call it &amp;lsquo;Kestrel&amp;rsquo;? Well, that is a surprisingly non-utilitarian name for a Microsoft coined term. Shouldn&amp;rsquo;t it be called &amp;ldquo;InProcessIISAlternative&amp;rdquo;? Possibly with IIS spelled out?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;/sarcasm&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So&amp;hellip;going on&amp;hellip;Use current directory as content root. Sure, integrate with IIS if you find it (tip: You won&amp;rsquo;t). Use an stance of &lt;code&gt;Startup&lt;/code&gt; as the startup object. All understandable. So why isn&amp;rsquo;t the bloody thing working?!&lt;/p&gt;

&lt;p&gt;Well, the problem is not in the code that&amp;rsquo;s there. The problem is in the code that &lt;strong&gt;is not&lt;/strong&gt; there. By default, a service started like this &lt;strong&gt;only&lt;/strong&gt; listens to &lt;code&gt;localhost:5000&lt;/code&gt;. That seems logical enough, right? It should work, right? Well yes, if you&amp;rsquo;re accessing form localhost.&lt;/p&gt;

&lt;p&gt;But, in our case, we are not. We are using Docker. Which means the service is running in a container. The container, from the perspective of our C# service, is &lt;code&gt;localhost&lt;/code&gt;. That means that anything accessing the container, almost by definition, will not be coming from &lt;code&gt;localhost&lt;/code&gt;, but rather as something more &lt;code&gt;remote&lt;/code&gt; from our application&amp;rsquo;s perspective.&lt;/p&gt;

&lt;p&gt;So, how to fix this? Well if you google around, you&amp;rsquo;re going to find a whole lot of information on configuration files you can edit. Maybe even for various stages like production or testing. I honestly didn&amp;rsquo;t really read into it that much. Not because I don&amp;rsquo;t care, but rather;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Application configuration files for network settings make no sense when you&amp;rsquo;re developing in containers. Whatever you configure in the configuration file, you can, and will override it when you deploy the container. For example, you could specify it with &lt;code&gt;-p&lt;/code&gt; or have Docker decide for you, or just ignore the port alltogether. Point is, the port that is going to be used to access your servie is not decided by your service. So don&amp;rsquo;t add another configuration file. Just hardcode it. You won&amp;rsquo;t be running any other services inside your container anyway, so port collisions are not an issue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And hardcode I did;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;var host = new WebHostBuilder()
                .UseUrls(&amp;quot;http://0.0.0.0:5000/&amp;quot;)
         		.UseContentRoot(Directory.GetCurrentDirectory())
                .UseStartup&amp;lt;Startup&amp;gt;()
                .Build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note I also deleted the IIS integration. I&amp;rsquo;ll have none of your shenanigans, IIS.&lt;/p&gt;

&lt;p&gt;After this, we end up with a runnable container;
&lt;asciinema-player src=&#34;http://staticsmustdie.net/asciinema/dotnet-jenkins-secondrun.json&#34; cols=&#34;90&#34; rows=&#34;20&#34; preload=&#34;true&#34; poster=&#34;npt:0:07&#34;&gt;&lt;/asciinema-player&gt;
&lt;/p&gt;

&lt;h3 id=&#34;crash-test-dummy&#34;&gt;Crash test dummy&lt;/h3&gt;

&lt;p&gt;So, I have a service running, a delivery pipeline  from the previous blog post, and actual value we can deliver to our shell using clients. At this point, even I am considering it might be smart to start adding some tests. The common practice for .NET projects seems to be to put the tests in a separate &amp;lsquo;project&amp;rsquo; if you will. So, create an empty directory, run &lt;code&gt;dotnet new -t xunittest&lt;/code&gt; and Bob&amp;rsquo;s your uncle.&lt;/p&gt;

&lt;p&gt;From here, it&amp;rsquo;s time implement the unit test. Again, not going to go into that much here. Suffice to say I managed to create something. If you&amp;rsquo;re interested on the unit test capabilities in (ASP).NET Core. There are some &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/tutorials/&#34; title=&#34;Awesome tutorials for learning ASP.NET core&#34;&gt;really excellent tutorials here&lt;/a&gt; - what are you even doing still reading this?&lt;/p&gt;

&lt;p&gt;Oh right. The Jenkins pipeline. So, as you might know (if you read the tutorials!) the command to run tests is a simple &lt;code&gt;dotnet test&lt;/code&gt;. If you want to capture the results in a file, you should add some parameters to &lt;code&gt;dotnet&lt;/code&gt; call. Still, should be easy enough to integrate into our pipeline.&lt;/p&gt;

&lt;p&gt;Also, since these are unit tests, I want to make sure they are run before any building of docker images or whatsoever. Here&amp;rsquo;s the code in the &lt;code&gt;Jenkinsfile&lt;/code&gt; for the (renewed!) building stage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt; stage(&#39;Build binaries&#39;){
  // Run this stage in a docker container with the dotnet sdk
  agent { docker &#39;microsoft/dotnet:latest&#39;}
  steps{
    git url: &#39;https://github.com/corstijank/blog-dotnet-jenkins.git&#39;
    sh &#39;cd TodoApi &amp;amp;&amp;amp; dotnet restore&#39;
    sh &#39;cd TodoApi.Test &amp;amp;&amp;amp; dotnet restore&#39;
    sh &#39;cd TodoApi.Test &amp;amp;&amp;amp; dotnet test -xml xunit-results.xml&#39;
    sh &#39;cd TodoApi &amp;amp;&amp;amp; dotnet publish project.json -c Release -r ubuntu.14.04-x64 -o ./publish&#39;
    stash includes: &#39;TodoApi/publish/**&#39;, name: &#39;prod_bins&#39; 
  }
  post{
    always{
      step([$class    : &#39;XUnitBuilder&#39;,
      thresholds: [[$class: &#39;FailedThreshold&#39;, failedThreshold: &#39;1&#39;]],
         tools     : [[$class: &#39;XUnitDotNetTestType&#39;, pattern: &#39;**/xunit-results.xml&#39;]]])
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are basically two things that are important here. First off, and most simple, is the &amp;lsquo;dotnet test&amp;rsquo; directive. We pipe the output to XML; which we are going to use in recording the results.&lt;/p&gt;

&lt;p&gt;In a &lt;code&gt;Jenkinsfile&lt;/code&gt;, each stage needs at least some &lt;code&gt;steps&lt;/code&gt;, obviously. But, we can also add a &lt;code&gt;post&lt;/code&gt; block. In this block, we can nest an &lt;code&gt;always&lt;/code&gt; block. Here, we can record our results using the XUnit plugin.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When you record test results in a &lt;code&gt;Jenkinsfile&lt;/code&gt;, be sure to always put the recording in something like a &lt;code&gt;post/always&lt;/code&gt; block, or if you&amp;rsquo;re using pure script, use a &lt;code&gt;try/finally&lt;/code&gt; construction. If your tests fail, the exit code will result in an exception. If you put the recording of your test results as a simple sequential step after the testing, it would mean execution would never reach the recording!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://staticsmustdie.net/img/dotnet-jenkins-tests-succesful.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;The serenity was not at a level I had hoped it to be&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://staticsmustdie.net/img/dotnet-jenkins-tests-failed.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Everything going as expected...&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;And&amp;hellip; that actually concludes integrating simple unit testing. It really was that easy.&lt;/p&gt;

&lt;p&gt;At first it might look like that amount of low-level &lt;code&gt;dotnet&lt;/code&gt; calls in our building stage might warrant some other, more abstract build tool to manage. But so far, I really don&amp;rsquo;t mind it. Having to, for example, fix the ordering between my source and test projects doesn&amp;rsquo;t seem like a big deal at all if you keep things small. For bigger things, well NuGet might help you with some dependency management there.&lt;/p&gt;

&lt;p&gt;There are &lt;strong&gt;probably&lt;/strong&gt; a whole bunch of cases where the &amp;lsquo;low-level&amp;rsquo; attitude of the &lt;code&gt;dotnet&lt;/code&gt; cli is going to fall short. I&amp;rsquo;m no experienced .NET developer. And I&amp;rsquo;m sure either Visual Studio or Team Foundation Server is going to offer some nice sugar on top, if they are not already. I don&amp;rsquo;t know.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m just using VSCode and Jenkins.&lt;/p&gt;

&lt;p&gt;And I don&amp;rsquo;t feel much need for anything else yet.&lt;/p&gt;

&lt;h2 id=&#34;wrap-up&#34;&gt;Wrap-up&lt;/h2&gt;

&lt;p&gt;So, that concludes the second part, in what looks like is going to be a three part adventure. The Jenkins pipeline we explored in the &lt;a href=&#34;http://staticsmustdie.net/post/dotnetcore-adventures-i/&#34;&gt;previous part&lt;/a&gt; was a fun introduction, but it was mostly dealing with Jenkins. This time around, we got into some interesting lessons on using ASP.NET Core with Docker, and what it would mean for configuration management.&lt;/p&gt;

&lt;p&gt;Also, it was very nice to see how relatively easy it is to integrate test results from the cli into Jenkins. I&amp;rsquo;ll admit that using the &lt;code&gt;step&lt;/code&gt; method is still a bit rough. I would rather use something like &lt;code&gt;xunit **/xunit-results.xml -t XUnitDotNetTest&lt;/code&gt; or something. But I&amp;rsquo;m sure the authors of the Jenkins plugin are going to get on that sometime.&lt;/p&gt;

&lt;p&gt;For the next post I plan on getting more creative; we have all the ground work laid out now. Let&amp;rsquo;s see what we can do with acceptance testing, docker-compose, and our Jenkins pipeline, to tear up and tear down a set of containers and some virtual networking as our acceptance testing environment. That&amp;rsquo;s when things start to look really interesting, I think.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>